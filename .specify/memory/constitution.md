<!--
Sync Impact Report:
- Version: 2.1.1 → 2.2.0 (Added detailed technical stack constraints)
- Changes:
  - Technology Stack: Added State Management (TanStack Query, MMKV), UI (NativeWind, Lucide),
    Forms (React Hook Form, Zod), Payment (Stripe), File/Media (Image Picker)
  - Secure Storage: Added Keychain/Keystore requirement
- Templates: ✅ plan-template.md, spec-template.md, tasks-template.md validated
- Follow-up: None
-->

# RN Demo Spec Constitution

## Mission

Build a production-grade React Native application using Expo (latest) that fully supports White-label (multi-brand) and Multi-tenant use cases. The system must be scalable, maintainable for 5+ years, and suitable for multi-developer teams and CI/CD pipelines.

## External Skills (Agent Guidelines)

This project uses the following Vercel agent-skills for AI-assisted development:

### vercel-react-native-skills
Located at: `.claude/skills/vercel-react-native-skills/`

**MUST reference these guidelines when:**
- Building React Native or Expo components
- Optimizing list and scroll performance (use FlashList, not FlatList)
- Implementing animations (use Reanimated, animate only transform/opacity)
- Working with images (use expo-image, not Image from react-native)
- Configuring navigation (use native stack/tabs)
- Managing state (minimize subscriptions, use dispatcher pattern)

**Key Rules:**
| Priority | Category | Rule |
|----------|----------|------|
| CRITICAL | Lists | Use FlashList, memoize items, stabilize callbacks |
| HIGH | Animation | Use Reanimated, animate only GPU properties |
| HIGH | Navigation | Use native stack/native tabs over JS navigators |
| HIGH | UI | Use expo-image, Pressable (not TouchableOpacity) |
| MEDIUM | State | Minimize state subscriptions, use Zustand patterns |
| MEDIUM | Rendering | Wrap text in Text components, avoid falsy && |

**Full documentation:** `.claude/skills/vercel-react-native-skills/AGENTS.md`

### vercel-composition-patterns
Located at: `.claude/skills/vercel-composition-patterns/`

**MUST reference when:**
- Refactoring components with many boolean props
- Building reusable component libraries
- Designing flexible component APIs

## Core Principles


### I. Clean Architecture / Modular Architecture

MUST follow Clean Architecture principles with feature-based modules (not screen-based):

- **Presentation Layer (UI)**: Components, screens, hooks for UI logic
- **Domain Layer (Business Logic)**: Business rules, entities, use cases
- **Data Layer**: API clients, persistence, external services
- Strict separation of concerns between layers
- Features MUST be brand-agnostic and tenant-agnostic
- Modules MUST be self-contained with clear boundaries
- Dependencies MUST point inward (UI → Domain → Data)

### II. Clear Folder Structure

Every feature MUST follow a documented folder organization. The project structure MUST include:

- `app/` - Application entry point, bootstrap, providers
- `modules/` - Feature-based, domain-driven modules (not screen-based)
- `shared/` - Reusable UI components, hooks, utilities
- `core/` - Core infrastructure:
  - `config/` - Brand, tenant, environment loader
  - `theme/` - Centralized design system
  - `api/` - Axios client and networking
  - `store/` - Redux Toolkit setup
  - `i18n/` - Localization
  - `logging/` - Logging abstraction
  - `errors/` - Error handling
- `assets/` - Brand-specific assets
- `app.json` / `app.config.js` - Expo configuration
- `ios/` and `android/` - Native project directories (generated by `expo prebuild`, can be customized)

Each directory MUST have a clear, documented purpose. No organizational-only directories without explicit purpose. Native code modifications MUST be done through Expo config plugins when possible; direct native code changes in `ios/` and `android/` require documentation.

### III. Separation of Concerns

MUST maintain strict separation between UI/Presentation layer and business logic:

- UI components (components, screens) MUST be presentational and receive data via props or Redux selectors
- Business logic (services, hooks, utilities) MUST be isolated from UI components
- UI components MUST NOT contain API calls, data transformation, or business rules
- Services handle data fetching and API communication
- Redux store manages application state; Redux slices organize state by feature domain
- Redux actions and thunks handle async operations and side effects
- UI components connect to Redux store via hooks (useSelector, useDispatch) or connect HOC
- Features MUST remain brand-agnostic and tenant-agnostic

### IV. Strong TypeScript Typing and Contracts

TypeScript MUST be used throughout the codebase:

- All data structures MUST have explicit interfaces/types
- Function parameters and return values MUST be typed
- API responses MUST use type contracts
- Component props MUST be typed with interfaces
- Avoid `any` type; use `unknown` with type guards when necessary
- Type contracts MUST be defined before implementation
- All configurations MUST be type-safe (brand, tenant, environment)

### V. Externalized Configuration

All configuration values MUST be externalized:

- API endpoints, feature flags, and constants MUST NOT be hardcoded
- Use environment variables or configuration files (`.env`, `app.config.js`)
- Leverage Expo's `Constants.expoConfig` for runtime configuration
- Configuration MUST be environment-specific (development, staging, production)
- Secrets and sensitive data MUST use secure environment variable management
- **Runtime configuration first; build-time configuration only when unavoidable**

### VI. White-label & Multi-tenant Design

#### White-label (Brand-specific)

Managed via Brand Configuration:

- App name (build-time)
- App icon (build-time)
- Splash screen (build-time)
- Color palette (runtime via theme system)
- Typography (runtime via theme system)
- Bundle ID / App ID (build-time)

#### Multi-tenant (Tenant-specific)

Managed via Tenant Configuration (runtime):

- API base URL
- Feature toggles
- Permissions / capabilities
- Tenant metadata
- Theme overrides (if required)

#### Build-time vs Runtime Decisions

**Build-time only:**

- App name
- Bundle ID
- App icon
- Splash screen

**Runtime:**

- Tenant selection
- API endpoints
- Feature flags
- Permissions
- Theme overrides (if required)

**Critical Rules:**

- Do NOT hardcode brand or tenant logic inside features
- UI MUST never access API or storage layers directly
- Theme values MUST NOT be embedded in components
- Features MUST remain brand-agnostic

### VII. Expo Prebuild Workflow

MUST use Expo (latest) with prebuild workflow:

- Use `npx expo prebuild` to generate native `ios/` and `android/` directories
- Native code in `ios/` and `android/` directories CAN be customized as needed
- Native modules SHOULD be added via Expo config plugins when possible, but direct native modifications are allowed
- After native code changes, run `npx expo prebuild --clean` to regenerate if config changes are made
- Use Expo SDK features and APIs for platform-specific functionality
- Native code modifications MUST be documented and version controlled
- Maintain ability to regenerate native projects from `app.json` / `app.config.js` configuration

## Technology Stack

### Core

**Framework**: Expo (latest)
**Language**: TypeScript (strict mode)
**Package Manager**: Yarn
**Platforms**: iOS and Android
**Native Code**: Customizable via `ios/` and `android/` directories (generated by `expo prebuild`)

### State Management

- **Server State**: TanStack Query (React Query) for API data fetching, caching, and synchronization
- **Local Persistence**: MMKV (preferred) or AsyncStorage for local data storage
- **Global State**: Redux Toolkit (RTK) with React-Redux hooks for complex client-side state

### Navigation

- **React Navigation** with scalable, type-safe architecture

### UI Components

- **Base**: Native components + custom components
- **Styling**: NativeWind (Tailwind for RN) OR StyleSheet (choose one per project)
- **Icons**: Lucide React Native

### API Integration

- **HTTP Client**: Axios with:
  - Custom API client abstraction
  - Request/Response interceptors
  - Token handling and refresh
- **Secure Storage**: Keychain (iOS) / Keystore (Android) for sensitive data (tokens, credentials)

### Forms & Validation

- **Form Management**: React Hook Form
- **Schema Validation**: Zod for runtime type validation and form schemas

### Payment

- **Stripe React Native** for payment processing

### File & Media

- **React Native Image Picker** for camera and gallery access

### Localization

- **i18n** (internationalization) for multi-language support

### Error Handling & Monitoring

- **Sentry** for error tracking and monitoring
- **Centralized logging** abstraction

### Testing

- **Jest** with React Native Testing Library

### CI/CD

- **GitHub Actions** with **Fastlane** for automated builds and deployments

### Feature Flags

- Remote configuration readiness for feature toggles

## Required Core Configurations

MUST implement the following core configurations:

- `brand.config.ts` - White-label brand definition (build-time)
- `tenant.config.ts` - Runtime tenant definition
- Centralized theme system (brand-aware, tenant-aware)
- Environment configuration loader (dev / staging / prod)
- API client abstraction (Axios-based with interceptors)
- Modular navigation setup (React Navigation)
- Error handling system (Sentry-ready)
- Logging abstraction
- Feature flags / Remote configuration system

## CI/CD Strategy

MUST support CI/CD pipelines using GitHub Actions and Fastlane:

### GitHub Actions Workflows

- Automated CI/CD pipelines for all builds and deployments
- Separate workflows for:
  - Brand builds (white-label configurations)
  - Environment deployments (development, staging, production)
  - Platform-specific builds (iOS, Android)
- Matrix builds for multiple brands and environments
- Automated testing, linting, and type checking before builds
- Secure secret management for certificates, keys, and API tokens

### Fastlane Configuration

- Fastlane lanes for iOS and Android builds
- Automated code signing and certificate management
- App Store and Play Store deployment automation
- Support for multiple build configurations per brand
- Environment-specific build variants
- Automated versioning and changelog management

### Build Strategy

- Support both:
  - Separate apps per tenant (different bundle IDs per brand)
  - Single app with runtime tenant selection
- Brand-specific build configurations via Fastlane lanes
- Automated asset injection (icons, splash screens) per brand
- Environment variable injection for API endpoints and feature flags
- Automated testing before deployment
- Rollback capabilities for production deployments

## Best Practices & Pitfalls

**MUST follow:**

- Do not hardcode brand or tenant logic inside features
- UI must never access API or storage layers directly
- Theme values must not be embedded in components
- All configurations must be type-safe
- Features must remain brand-agnostic
- Runtime configuration first; build-time configuration only when unavoidable

**MUST avoid:**

- Screen-based folder organization (use feature-based modules)
- Direct API calls in UI components
- Hardcoded theme values in components
- Brand or tenant-specific logic in feature modules
- Build-time configuration for runtime decisions

## Development Workflow

**Project Initialization**: All new projects MUST be initialized using:

```bash
npx create-expo-app my-app --template bare-minimum
```

This ensures a clean starting point with minimal dependencies and full control over native code customization.

**Code Review**: All PRs MUST verify compliance with constitution principles  
**Testing**: Unit tests for services and utilities; component tests for UI components  
**Type Safety**: TypeScript compilation MUST pass with no errors  
**Linting**: Code MUST pass ESLint and TypeScript checks before merge  
**Documentation**: Folder structure and component purpose MUST be documented

## Long-term Philosophy

The application must:

- Change brands without code changes
- Add tenants without rebuilding
- Add features without impacting the core system

Architecture priorities:

- Maintainability
- Scalability
- Fast team onboarding

## Governance

Constitution supersedes all other development practices. Amendments require:

- Documentation of rationale
- Approval process
- Migration plan for existing code

All PRs and code reviews MUST verify compliance with constitution principles. Complexity MUST be justified. Violations of core principles require explicit exception documentation.

**Version**: 2.2.0 | **Ratified**: 2025-01-27 | **Last Amended**: 2026-02-04

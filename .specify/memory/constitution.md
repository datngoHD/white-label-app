<!--
Sync Impact Report:
- Version: 1.2.0 → 2.0.0 → 2.1.0 → 2.1.1 (Added project initialization requirement)
- Mission: Added white-label and multi-tenant application mission
- Principles: Updated folder structure, added Clean Architecture principles, white-label/multi-tenant design
- Technology Stack: Expanded with mandatory technologies (Yarn, React Navigation, Axios, i18n, Sentry-ready)
- Architecture: Added feature-based modules, runtime configuration priority
- CI/CD: Updated from EAS Build to GitHub Actions with Fastlane
- Development Workflow: Added mandatory project initialization with bare-minimum template
- Templates: ⚠️ plan-template.md, spec-template.md, tasks-template.md require validation
-->

# RN Demo Spec Constitution

## Mission

Build a production-grade React Native application using Expo (latest) that fully supports White-label (multi-brand) and Multi-tenant use cases. The system must be scalable, maintainable for 5+ years, and suitable for multi-developer teams and CI/CD pipelines.

## Core Principles

### I. Clean Architecture / Modular Architecture

MUST follow Clean Architecture principles with feature-based modules (not screen-based):

- **Presentation Layer (UI)**: Components, screens, hooks for UI logic
- **Domain Layer (Business Logic)**: Business rules, entities, use cases
- **Data Layer**: API clients, persistence, external services
- Strict separation of concerns between layers
- Features MUST be brand-agnostic and tenant-agnostic
- Modules MUST be self-contained with clear boundaries
- Dependencies MUST point inward (UI → Domain → Data)

### II. Clear Folder Structure

Every feature MUST follow a documented folder organization. The project structure MUST include:

- `app/` - Application entry point, bootstrap, providers
- `modules/` - Feature-based, domain-driven modules (not screen-based)
- `shared/` - Reusable UI components, hooks, utilities
- `core/` - Core infrastructure:
  - `config/` - Brand, tenant, environment loader
  - `theme/` - Centralized design system
  - `api/` - Axios client and networking
  - `store/` - Redux Toolkit setup
  - `i18n/` - Localization
  - `logging/` - Logging abstraction
  - `errors/` - Error handling
- `assets/` - Brand-specific assets
- `app.json` / `app.config.js` - Expo configuration
- `ios/` and `android/` - Native project directories (generated by `expo prebuild`, can be customized)

Each directory MUST have a clear, documented purpose. No organizational-only directories without explicit purpose. Native code modifications MUST be done through Expo config plugins when possible; direct native code changes in `ios/` and `android/` require documentation.

### III. Separation of Concerns

MUST maintain strict separation between UI/Presentation layer and business logic:

- UI components (components, screens) MUST be presentational and receive data via props or Redux selectors
- Business logic (services, hooks, utilities) MUST be isolated from UI components
- UI components MUST NOT contain API calls, data transformation, or business rules
- Services handle data fetching and API communication
- Redux store manages application state; Redux slices organize state by feature domain
- Redux actions and thunks handle async operations and side effects
- UI components connect to Redux store via hooks (useSelector, useDispatch) or connect HOC
- Features MUST remain brand-agnostic and tenant-agnostic

### IV. Strong TypeScript Typing and Contracts

TypeScript MUST be used throughout the codebase:

- All data structures MUST have explicit interfaces/types
- Function parameters and return values MUST be typed
- API responses MUST use type contracts
- Component props MUST be typed with interfaces
- Avoid `any` type; use `unknown` with type guards when necessary
- Type contracts MUST be defined before implementation
- All configurations MUST be type-safe (brand, tenant, environment)

### V. Externalized Configuration

All configuration values MUST be externalized:

- API endpoints, feature flags, and constants MUST NOT be hardcoded
- Use environment variables or configuration files (`.env`, `app.config.js`)
- Leverage Expo's `Constants.expoConfig` for runtime configuration
- Configuration MUST be environment-specific (development, staging, production)
- Secrets and sensitive data MUST use secure environment variable management
- **Runtime configuration first; build-time configuration only when unavoidable**

### VI. White-label & Multi-tenant Design

#### White-label (Brand-specific)

Managed via Brand Configuration:

- App name (build-time)
- App icon (build-time)
- Splash screen (build-time)
- Color palette (runtime via theme system)
- Typography (runtime via theme system)
- Bundle ID / App ID (build-time)

#### Multi-tenant (Tenant-specific)

Managed via Tenant Configuration (runtime):

- API base URL
- Feature toggles
- Permissions / capabilities
- Tenant metadata
- Theme overrides (if required)

#### Build-time vs Runtime Decisions

**Build-time only:**

- App name
- Bundle ID
- App icon
- Splash screen

**Runtime:**

- Tenant selection
- API endpoints
- Feature flags
- Permissions
- Theme overrides (if required)

**Critical Rules:**

- Do NOT hardcode brand or tenant logic inside features
- UI MUST never access API or storage layers directly
- Theme values MUST NOT be embedded in components
- Features MUST remain brand-agnostic

### VII. Expo Prebuild Workflow

MUST use Expo (latest) with prebuild workflow:

- Use `npx expo prebuild` to generate native `ios/` and `android/` directories
- Native code in `ios/` and `android/` directories CAN be customized as needed
- Native modules SHOULD be added via Expo config plugins when possible, but direct native modifications are allowed
- After native code changes, run `npx expo prebuild --clean` to regenerate if config changes are made
- Use Expo SDK features and APIs for platform-specific functionality
- Native code modifications MUST be documented and version controlled
- Maintain ability to regenerate native projects from `app.json` / `app.config.js` configuration

## Technology Stack

**Framework**: Expo (latest)  
**Language**: TypeScript (by default)  
**Package Manager**: Yarn  
**State Management**: Redux Toolkit (RTK) with React-Redux hooks  
**Navigation**: React Navigation with scalable architecture  
**HTTP Client**: Axios with:

- Custom API client
- Interceptors
- Token handling
  **Localization**: i18n (internationalization)  
  **Error Handling**: Sentry-ready error handling  
  **Logging**: Centralized logging abstraction  
  **Feature Flags**: Remote configuration readiness  
  **Testing**: Jest with React Native Testing Library  
  **Platforms**: iOS and Android  
  **CI/CD**: GitHub Actions with Fastlane  
  **Native Code**: Customizable via `ios/` and `android/` directories (generated by `expo prebuild`)

## Required Core Configurations

MUST implement the following core configurations:

- `brand.config.ts` - White-label brand definition (build-time)
- `tenant.config.ts` - Runtime tenant definition
- Centralized theme system (brand-aware, tenant-aware)
- Environment configuration loader (dev / staging / prod)
- API client abstraction (Axios-based with interceptors)
- Modular navigation setup (React Navigation)
- Error handling system (Sentry-ready)
- Logging abstraction
- Feature flags / Remote configuration system

## CI/CD Strategy

MUST support CI/CD pipelines using GitHub Actions and Fastlane:

### GitHub Actions Workflows

- Automated CI/CD pipelines for all builds and deployments
- Separate workflows for:
  - Brand builds (white-label configurations)
  - Environment deployments (development, staging, production)
  - Platform-specific builds (iOS, Android)
- Matrix builds for multiple brands and environments
- Automated testing, linting, and type checking before builds
- Secure secret management for certificates, keys, and API tokens

### Fastlane Configuration

- Fastlane lanes for iOS and Android builds
- Automated code signing and certificate management
- App Store and Play Store deployment automation
- Support for multiple build configurations per brand
- Environment-specific build variants
- Automated versioning and changelog management

### Build Strategy

- Support both:
  - Separate apps per tenant (different bundle IDs per brand)
  - Single app with runtime tenant selection
- Brand-specific build configurations via Fastlane lanes
- Automated asset injection (icons, splash screens) per brand
- Environment variable injection for API endpoints and feature flags
- Automated testing before deployment
- Rollback capabilities for production deployments

## Best Practices & Pitfalls

**MUST follow:**

- Do not hardcode brand or tenant logic inside features
- UI must never access API or storage layers directly
- Theme values must not be embedded in components
- All configurations must be type-safe
- Features must remain brand-agnostic
- Runtime configuration first; build-time configuration only when unavoidable

**MUST avoid:**

- Screen-based folder organization (use feature-based modules)
- Direct API calls in UI components
- Hardcoded theme values in components
- Brand or tenant-specific logic in feature modules
- Build-time configuration for runtime decisions

## Development Workflow

**Project Initialization**: All new projects MUST be initialized using:

```bash
npx create-expo-app my-app --template bare-minimum
```

This ensures a clean starting point with minimal dependencies and full control over native code customization.

**Code Review**: All PRs MUST verify compliance with constitution principles  
**Testing**: Unit tests for services and utilities; component tests for UI components  
**Type Safety**: TypeScript compilation MUST pass with no errors  
**Linting**: Code MUST pass ESLint and TypeScript checks before merge  
**Documentation**: Folder structure and component purpose MUST be documented

## Long-term Philosophy

The application must:

- Change brands without code changes
- Add tenants without rebuilding
- Add features without impacting the core system

Architecture priorities:

- Maintainability
- Scalability
- Fast team onboarding

## Governance

Constitution supersedes all other development practices. Amendments require:

- Documentation of rationale
- Approval process
- Migration plan for existing code

All PRs and code reviews MUST verify compliance with constitution principles. Complexity MUST be justified. Violations of core principles require explicit exception documentation.

**Version**: 2.1.1 | **Ratified**: 2025-01-27 | **Last Amended**: 2025-01-27
